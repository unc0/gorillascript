<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <title>GorillaScript</title>
  <link rel="stylesheet" href="css/style.css" />
	<link rel="stylesheet" href="css/prism.css" />
</head>
<body>
	<header>
		<svg version="1.1" id="gorilla-logo" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
			 width="60px" height="60px" viewBox="0 0 243 279.339" enable-background="new 0 0 243 279.339" xml:space="preserve">
		<g id="logo-face" fill="#2b2b2b">
			<polygon id="logo-face-fill" fill="#FFFFFF" points="8,204.225 8,74.428 121.5,9.226 235,74.428 235,204.225 121.5,270.112"/>
			<path id="logo-face-profile" d="M121.5,0L0,69.797v139.631l121.5,69.798L243,209.429V69.797L121.5,0z M8,204.225V74.428L121.5,9.226 L235,74.428v129.797l-113.5,65.888"/>
			<polygon id="logo-beard" points="180.751,229.225 121.5,263.262 62.25,229.225"/>
			<polygon id="logo-mouth" points="213.134,203.225 121.499,195.232 29.866,203.225"/>
			<g id="logo-nose">
				<polygon id="logo-nose-right" points="129,139.778 129,164.112 150,151.443 150,128.112"/>
				<polygon id="logo-nose-left" points="114,139.778 114,164.112 93,151.443 93,128.112"/>
			</g>
			<g id="logo-cheek">
				<path id="logo-cheek-left" d="M14,196.999V100.78l42.318,26L14,196.999z"/>
				<path id="logo-cheek-right" d="M229,196.999l-42.318-70.219l42.318-26V196.999z"/>
			</g>
			<path id="logo-hair" d="M177.285,47.225H65.714L121.5,15.178L177.285,47.225z"/>
			<g id="logo-eyes">
				<g id="logo-eyes-rims">
					<polygon id="logo-eyes-rims-right" points="141.512,72.225 133,83.953 153.293,116.316 222.803,72.225"/>
					<polygon id="logo-eyes-rims-left" points="101.838,72.225 20.547,72.225 89.707,116.116 110.35,83.953"/>
				</g>
				<polygon id="logo-eyes-right" fill="#FFFFFF" points="142.169,88.299 162.532,75.993 183.739,87.926 162.477,99.785"/>
				<polygon id="logo-eyes-left" fill="#FFFFFF" points="80.873,99.785 59.61,87.926 80.817,75.993 101.181,88.299"/>
			</g>
		</g>
		</svg>
		<h1 class="logo">GorillaScript <span id="github"><a href="http://github.com/ckknight/gorillascript">Fork on Github</a></span></h1>
		
		<p>a compile-to-JavaScript language designed to empower the user while attempting to prevent some common errors.</p>
	</header>
	<h3 id="toc-label"><a href="#">Table of contents</a></h3>
  <nav id="toc">
    <ul>
      <li><a href="#why-not-js">Why not use JavaScript?</a>
      <li><a href="#strict-equality">Strict vs unstrict equality</a>
      <li><a href="#addition">The <code>+</code> operator (and <code>+=</code>)</a>
      <li><a href="#strict-mode-by-default">Strict mode by default</a>
      <li><a href="#type-safety-of-operators">Type safety of operators</a>
      <li><a href="#immutable-by-default">Immutable by default</a>
      <li><a href="#indentation">Indentation to mark code blocks</a>
      <li><a href="#changed-operators">Changed operators</a>
      <li><a href="#function-syntax">Slightly nicer function syntax</a>
      <li><a href="#string-interpolation">String interpolation</a>
      <li><a href="#optional-parameters">Optional parameters</a>
      <li><a href="#spread-parameters">Spread parameters</a>
      <li><a href="#dashed-identifiers">Dashed-identifiers</a>
      <li><a href="#numbers">Nicer number syntax</a>
      <li><a href="#strings">Some new string syntaxes</a>
      <li><a href="#objects-and-arrays">Nicer syntaxes for objects and arrays</a>
      <li><a href="#maps-and-sets">First-class support for Maps and Sets</a>
      <li><a href="#unless">Unless statement</a>
      <li><a href="#loops">Loops</a>
      <li><a href="#lexical-scope">Lexical scoping in loops</a>
      <li><a href="#array-slicing">Array slicing</a>
      <li><a href="#array-negative-index">Array negative indexing</a>
      <li><a href="#expressions">Everything is an expression (mostly)</a>
      <li><a href="#existential">Existential operator</a>
      <li><a href="#in"><code>in</code> operator</a>
      <li><a href="#haskey-ownskey"><code>haskey</code> and <code>ownskey</code></a>
      <li><a href="#ownership">Access with ownership</a>
      <li><a href="#apply">Apply syntax</a>
      <li><a href="#bind">Binding access</a>
      <li><a href="#classes">Classes</a>
      <li><a href="#destructuring">Destructuring</a>
      <li><a href="#switch">Switch</a>
      <li><a href="#try-catch">Try-catch-else-finally</a>
      <li><a href="#regexes">Regular Expressions</a>
      <li><a href="#custom-interpolation">Custom interpolation strings</a>
      <li><a href="#iterators">Iterators</a>
      <li><a href="#async">Async</a>
      <li><a href="#promises">Promises</a>
      <li><a href="#typing">Optional typing</a>
      <li><a href="#operators-as-functions">Operators, accesses, and method calls as functions</a>
      <li><a href="#properties">Getters and setters</a>
      <li><a href="#labels">Labels and <code>break</code>/<code>continue</code></a>
      <li><a href="#global">The <code>GLOBAL</code> identifier</a>
      <li><a href="#curry">Curried functions</a>
      <li><a href="#generic">Generics</a>
      <li><a href="#gnome">GNOME bindings</a>
      <li><a href="#gork">Gork and Gorkfiles</a>
      <li><a href="#browser">Browser support</a>
      <li><a href="#irc">Chat with others (IRC)</a>
    </ul>
  </nav>
  <div id="try">
		<div class="code">
			<div id="try-input-wrap">
				<textarea id="try-input" rows="100" spellcheck="false">alert "Hello, GorillaScript!"</textarea>
			</div>
			<div id="try-output-wrap">
				<textarea id="try-output" readonly></textarea>
			</div>
		</div>
  </div>
	<nav id="try-bar">
		<a href="#try" id="try-link" class="hide">Try it out</a>
		<a href="#run" id="run-link" class="hide">Run</a>
	</nav>
	<div id="container">
  <section id="why-not-js">
    <h2>Why not use JavaScript?</h2>
    <p>JavaScript has a lot of warts in the language and while the ECMAScript community is doing a good job with its upcoming revisions, it&#8217;s still left with a lot of the old cruft. Also, for those who want to code for older browsers, all the shiny new features that the newer versions of ECMAScript provide are for all intents and purposes unreachable.</p>
  </section>
  
  <section id="strict-equality">
    <h2>Strict vs unstrict equality</h2>
    <p><code class="language-javascript">==</code> and <code class="language-javascript">!=</code> perform type coercion behind the scenes and can be the cause of some subtle bugs.</p>
    
    <pre class="js-code"><code class="language-javascript">// JavaScript, all the following are true
1 == "1"
0 != ""
3 == "03"
[] == ""
[] == 0
[] == ![]
[] == false
null != false
null == undefined
</code></pre>

    <p>These could all be fixed by adding an extra equal sign, but GorillaScript makes <code class="language-gorillascript">==</code> and <code class="language-gorillascript">!=</code> strict by default. If one really wants the unstrict equality operators, one can use <code class="language-gorillascript">~=</code> and <code class="language-gorillascript">!~=</code>, but it is not recommended except for comparing against null or undefined, which has the nice postfix operator <code class="language-gorillascript">?</code>.</p>
  </section>
  
  <section id="addition">
    <h2>The <code>+</code> operator (and <code>+=</code>)</h2>

    <p><code class="language-javascript">+</code> can mean one of two things in JavaScript, addition or string concatenation. There is no way to know at compile-time what the consequences of using <code class="language-javascript">+</code> is unless one is 100% certain what each type is.</p>

    <pre class="js-code"><code class="language-javascript">x + y
</code></pre>

    <p>Is addition unless both <code class="language-javascript">x</code> and both <code class="language-javascript">y</code> are numbers, booleans, undefined, or null, with any mixed variation. If either is not one of those, at which point it performs string concatenation.</p>

    <pre class="js-code"><code class="language-javascript">// JavaScript
1 + 2 === 3 // as expected
"hello, " + "world" === "hello, world" // as expected
"hello, " + 123 === "hello, 123" // sure, I can accept this
"1" + 2 === "12"
1 + "2" === "12"

// and for some oddities
false + false === 0
false + true === 1
true + true === 2
null + null === 0
isNaN(undefined + undefined)
[] + [] === ""
{} + {} === "[object Object][object Object]"
true + [] === "true"
new Date() + 1 === "Tue Jan 29 2013 20:25:58 GMT-0800 (PST)1" // or something like it
new Date() - 1 === 1359519958072 // or some other number
var foo = {
  toString: function () { return 5; }
  valueOf: function () { return "foo"; }
};
foo.toString() + 1 === 6
foo + 1 === "foo1"
</code></pre>

    <p>GorillaScript solves this by splitting the operator into two: both <code class="language-gorillascript">+</code> for addition and <code class="language-gorillascript">&amp;</code> for string concatenation.</p>

    <pre class="gs-code no-convert"><code class="language-gorillascript">// GorillaScript
1 + 2 == 3
"hello, " &amp; "world" == "hello, world"
"hello, " &amp; 123 == "hello, 123" // concatenation with numbers still works perfectly fine
1 &amp; 2 == "12" // despite both being numbers, &amp; always makes a string.

1 + "2" // TypeError
"1" + 2 // TypeError
"1" + "2" // TypeError
false + false // TypeError
null + null // TypeError
void + void // TypeError
[] + [] // TypeError
{} + {} // TypeError
new Date() + 1 // TypeError
new Date().getTime() + 1 == 1359519958072 // or some other number
</code></pre>

    <p>As can be seen, the operators which don&#8217;t fit the proper types exactly fail immediately, allowing one to catch bugs as early as possible rather than allowing them to permeate through one&#8217;s programs.</p>

    <p>Don&#8217;t be worried about losing the bitwise and operator, that is now called <code class="language-gorillascript">bitand</code>.</p>
  </section>
  
  <section id="strict-mode-by-default">
    <h2>Strict mode by default</h2>

    <p>All GorillaScript code is wrapped in an immediately-invoked function expression (IIFE) which has the declaration of <code class="language-javascript">"use strict"</code>. This ensures that on the engines that support it, strict semantics will be followed, meaning less bugs in the long run.</p>
  </section>
  
  <section id="type-safety-of-operators">
    <h2>Type safety of operators</h2>

    <p>All operators check the types of their operands to assure that there will be no improper inputs and that any errors that do occur are caught as early as possible.</p>

    <ul>
    <li><code class="language-gorillascript">==</code> and <code class="language-gorillascript">!=</code> do not check the types, since they are already strict by default (in GorillaScript).</li>
    <li><code class="language-gorillascript">&lt;</code>, <code class="language-gorillascript">&gt;</code>, <code class="language-gorillascript">&lt;=</code>, <code class="language-gorillascript">&gt;=</code> are restricted to primitive <code class="language-gorillascript">String</code>s and <code class="language-gorillascript">Number</code>s, but never mixing the two.</li>
    <li><code class="language-gorillascript">+</code> only works on primitive <code class="language-gorillascript">Number</code>s.</li>
    <li><code class="language-gorillascript">&amp;</code>, the new string concatenation operator, works on primitive <code class="language-gorillascript">String</code>s and <code class="language-gorillascript">Number</code>s.</li>
    <li><code class="language-gorillascript">-</code>, <code class="language-gorillascript">*</code>, <code class="language-gorillascript">/</code>, <code class="language-gorillascript">\</code> (floor division), <code class="language-gorillascript">%</code>, <code class="language-gorillascript">%%</code> (divisible-by), <code class="language-gorillascript">^</code> (exponentiation, not bitwise xor), <code class="language-gorillascript">bitand</code> (instead of <code class="language-gorillascript">&amp;</code>), <code class="language-gorillascript">bitor</code> (instead of <code class="language-gorillascript">|</code>), <code class="language-gorillascript">bitxor</code> (instead of <code class="language-gorillascript">^</code>), <code class="language-gorillascript">bitnot</code> (instead of <code class="language-gorillascript">~</code>), <code class="language-gorillascript">bitlshift</code> (instead of <code class="language-gorillascript">&lt;&lt;</code>), <code class="language-gorillascript">bitrshift</code> (instead of <code class="language-gorillascript">&gt;&gt;</code>), <code class="language-gorillascript">biturshift</code> (instead of <code class="language-gorillascript">&gt;&gt;&gt;</code>), <code class="language-gorillascript">-</code> (unary negate), <code class="language-gorillascript">+</code> (unary coerce-to-number), and all their respective assignment operators (<code class="language-gorillascript">-=</code>, <code class="language-gorillascript">+=</code>, etc.) all only work on primitive <code class="language-gorillascript">Number</code>s.</li>
    </ul>

    <p>No other operators&#8217; types are checked.</p>

    <p>If one really wishes to work in an environment where the operands&#8217; types are not checked, one can always prepend the operator with <code class="language-gorillascript">~</code>, so there is a <code class="language-gorillascript">~*</code> operator which performs multiplication without checking. It is recommended to instead parse input data into conforming types before performing operations on them.</p>

    <p>Thankfully, GorillaScript is able to tell which types most values are, so in the general case, there should be little to no runtime type checking occurring.</p>
  </section>
  
  <section id="immutable-by-default">
    <h2>Immutable by default</h2>

    <p>GorillaScript uses two separate tokens for declaration as compared to assignment. Also, instead of JavaScript&#8217;s <code class="language-javascript">var</code> keyword, GorillaScript uses <code class="language-gorillascript">let</code>. Unless one specifies <code class="language-gorillascript">let mutable</code>, the local constant cannot be reset to any other value. The object in the value can still be mutated (assuming it is mutable). This can prevent some errors and often helps with the clarity of one&#8217;s code.</p>

    <p>Also, no undeclared variables can be altered, preventing unexpected global pollution (and typos).</p>

    <pre class="gs-code no-convert"><code class="language-gorillascript">let x = 5
x := 6 // Error
let mutable y = 5
y := 6 // perfectly fine
z := 6 // never declared, this is an error
</code></pre>

    <p>As you may have noticed, there are two different operators for declaration <code class="language-gorillascript">=</code> as compared to assignment <code class="language-gorillascript">:=</code>. This is to clarify the difference. In an ideal program, having as little mutable state as possible is best, so if <code class="language-gorillascript">:=</code> jumps out, that&#8217;s a good thing.</p>
  </section>

  <section id="indentation">
    <h2>Indentation to mark code blocks</h2>

    <p>Instead of using braces to dictate code blocks, GorillaScript opts for whitespace indentation as a way to mark blocks. Although this may be jarring at first and one may be skeptical, any good programmer properly indents his or her code to have a consistent whitespace anyway. GorillaScript does not dictate how many spaces or tabs are used, as long as it is consistent within any given block.</p>

    <pre class="gs-code"><code class="language-gorillascript">if hello
  if loudly
    "HELLO!"
  else
    "hi"
else
  "Goodbye."
</code></pre>

    <p>You may have also noticed the lack of semicolons. The parser is able to tell when the end of a statement is without them, so they are unnecessary.</p>
  </section>
  
  <section id="changed-operators">
    <h2>Changed operators</h2>

    <p>Many of the operators have changed to provide more clarity or to free up the usage of certain symbols.</p>

    <ul>
      <li><code class="language-javascript">===</code> - <code class="language-gorillascript">==</code></li>
      <li><code class="language-javascript">!==</code> - <code class="language-gorillascript">!=</code></li>
      <li><code class="language-javascript">==</code> - <code class="language-gorillascript">~=</code></li>
      <li><code class="language-javascript">!=</code> - <code class="language-gorillascript">!~=</code></li>
      <li><code class="language-javascript">!x</code> - <code class="language-gorillascript">not x</code></li>
      <li><code class="language-javascript">+</code> - <code class="language-gorillascript">+</code> for addition, <code class="language-gorillascript">&amp;</code> for string concatenation, type-checked</li>
      <li><code class="language-javascript">&amp;</code> - <code class="language-gorillascript">bitand</code>, type-checked</li>
      <li><code class="language-javascript">|</code> - <code class="language-gorillascript">bitor</code>, type-checked</li>
      <li><code class="language-javascript">^</code> - <code class="language-gorillascript">bitxor</code>, type-checked</li>
      <li><code class="language-javascript">~x</code> - <code class="language-gorillascript">bitnot x</code>, type-checked</li>
      <li><code class="language-javascript">&lt;&lt;</code> - <code class="language-gorillascript">bitlshift</code>, type-checked</li>
      <li><code class="language-javascript">&gt;&gt;</code> - <code class="language-gorillascript">bitrshift</code>, type-checked</li>
      <li><code class="language-javascript">&gt;&gt;&gt;</code> - <code class="language-gorillascript">biturshift</code>, type-checked</li>
      <li><code class="language-javascript">--x</code> - <code class="language-gorillascript">x -= 1</code>, type-checked</li>
      <li><code class="language-javascript">++x</code> - <code class="language-gorillascript">x += 1</code>, type-checked</li>
      <li><code class="language-javascript">x--</code> - <code class="language-gorillascript">post-dec! x</code>, not recommended except for advanced cases</li>
      <li><code class="language-javascript">x++</code> - <code class="language-gorillascript">post-inc! x</code>, not recommended except for advanced cases</li>
      <li><code class="language-javascript">&amp;&amp;</code> - <code class="language-gorillascript">and</code></li>
      <li><code class="language-javascript">||</code> - <code class="language-gorillascript">or</code>, can no longer be used with <code class="language-gorillascript">and</code> unless one group is in parentheses.</li>
      <li><code class="language-javascript">x ? y : z</code> - <code class="language-gorillascript">if x then y else z</code></li>
      <li><code class="language-javascript">key in obj</code> - <code class="language-gorillascript">obj haskey key</code>, reversed arguments. Can use <code class="language-gorillascript">not haskey</code></li>
      <li><code class="language-javascript">obj instanceof constructor</code> - Can also use <code class="language-gorillascript">not instanceof</code></li>
      <li><code class="language-javascript">delete x.y</code> - Returns the value of <code class="language-gorillascript">x.y</code> as well as deleting. Does not work on global variables anymore, use <code class="language-gorillascript">delete GLOBAL.x</code></li>
    </ul>

    <p>Kept the same:</p>

    <ul>
      <li><code class="language-gorillascript">&lt;</code> - type-checked</li>
      <li><code class="language-gorillascript">&lt;=</code> - type-checked</li>
      <li><code class="language-gorillascript">&gt;</code> - type-checked</li>
      <li><code class="language-gorillascript">&gt;=</code> - type-checked</li>
      <li><code class="language-gorillascript">-</code> - type-checked</li>
      <li><code class="language-gorillascript">*</code> - type-checked</li>
      <li><code class="language-gorillascript">/</code> - type-checked</li>
      <li><code class="language-gorillascript">%</code> - type-checked</li>
      <li><code class="language-gorillascript">-x</code> - type-checked</li>
      <li><code class="language-gorillascript">+x</code> - type-checked</li>
      <li><code class="language-gorillascript">x[y]</code></li>
      <li><code class="language-gorillascript">typeof x</code></li>
      <li><code class="language-gorillascript">throw x</code> - Can now be used as an expression like <code class="language-gorillascript">x or throw y</code></li>
    </ul>

    <p>Added:</p>

    <ul>
      <li><code class="language-gorillascript">typeof! x</code> - displays the constructor name of the object, <code class="language-gorillascript">typeof! {} == "Object"</code>, <code class="language-gorillascript">typeof! [] == "Array"</code></li>
      <li><code class="language-gorillascript">throw? x</code> - Only throws <code class="language-gorillascript">x</code> if <code class="language-gorillascript">x</code> is not null or undefined.</li>
      <li><code class="language-gorillascript">x ^ y</code> - Same as <code class="language-gorillascript">Math.pow(x, y)</code></li>
      <li><code class="language-gorillascript">x \ y</code> - Same as <code class="language-gorillascript">Math.floor(x / y)</code></li>
      <li><code class="language-gorillascript">xor</code> - For logical completeness with <code class="language-gorillascript">and</code> and <code class="language-gorillascript">or</code></li>
      <li><code class="language-gorillascript">x and= y</code> - Same as <code class="language-gorillascript">if x then x := y</code></li>
      <li><code class="language-gorillascript">x or= y</code> - Same as <code class="language-gorillascript">if not x then x := y</code></li>
      <li><code class="language-gorillascript">x in y</code> - Does <code class="language-gorillascript">x</code> exist in array <code class="language-gorillascript">y</code>. Can use <code class="language-gorillascript">not in</code>. Highly efficient if <code class="language-gorillascript">y</code> is a literal array.</li>
      <li><code class="language-gorillascript">x ownskey y</code> - Does <code class="language-gorillascript">x</code> own the property named <code class="language-gorillascript">y</code>. Can use <code class="language-gorillascript">not ownskey</code></li>
      <li><code class="language-gorillascript">x &lt;=&gt; y</code> - if x == y, 0. if x &lt; y, -1. otherwise, 1.</li>
      <li><code class="language-gorillascript">x %% y</code> - Is x divisible by <code class="language-gorillascript">y</code>? Same as <code class="language-gorillascript">x % y == 0</code>.</li>
      <li><code class="language-gorillascript">x min y</code> - Choose the lower number or lexicographically lesser string</li>
      <li><code class="language-gorillascript">x min= y</code> - If <code class="language-gorillascript">y</code> is less than <code class="language-gorillascript">x</code>, set <code class="language-gorillascript">x</code> to <code class="language-gorillascript">y</code>.</li>
      <li><code class="language-gorillascript">x max y</code> - Choose the higher number or lexicographically greater string</li>
      <li><code class="language-gorillascript">x max= y</code> - If <code class="language-gorillascript">y</code> is greater than <code class="language-gorillascript">x</code>, set <code class="language-gorillascript">x</code> to <code class="language-gorillascript">y</code>.</li>
      <li><code class="language-gorillascript">x?</code> - Is <code class="language-gorillascript">x</code> <code class="language-gorillascript">null</code> or <code class="language-gorillascript">undefined</code>?</li>
      <li><code class="language-gorillascript">x ? y</code> - If <code class="language-gorillascript">x</code> is <code class="language-gorillascript">null</code> or <code class="language-gorillascript">undefined</code>, then <code class="language-gorillascript">y</code>, otherwise keep the value of <code class="language-gorillascript">x</code>. <code class="language-gorillascript">y</code> may not be executed.</li>
      <li><code class="language-gorillascript">x ?= y</code> - If <code class="language-gorillascript">x</code> is <code class="language-gorillascript">null</code> or <code class="language-gorillascript">undefined</code>, then set <code class="language-gorillascript">x</code> to <code class="language-gorillascript">y</code>. <code class="language-gorillascript">y</code> may not be executed.</li>
      <li><code class="language-gorillascript">is-array! x</code> - True if <code class="language-gorillascript">x</code> is an Array (and not just an Array-like object). Works on arrays from a different context.</li>
      <li><code class="language-gorillascript">is-object! x</code> - True if <code class="language-gorillascript">x</code> is an Object and not null. Works on objects from a different context.</li>
      <li><code class="language-gorillascript">x to y</code> - Create an array from <code class="language-gorillascript">x</code> to inclusive <code class="language-gorillascript">y</code>.</li>
      <li><code class="language-gorillascript">x til y</code> - Create an array from <code class="language-gorillascript">x</code> until exclusive <code class="language-gorillascript">y</code>.</li>
      <li><code class="language-gorillascript">array by step</code> - Take every <code class="language-gorillascript">step</code>th value from the array. If <code class="language-gorillascript">step</code> is less than 0, go in reverse.</li>
      <li><code class="language-gorillascript">x to y by step</code> - Create an array from <code class="language-gorillascript">x</code> to inclusive <code class="language-gorillascript">y</code>, stepping by <code class="language-gorillascript">step</code>.</li>
      <li><code class="language-gorillascript">x til y by step</code> - Create an array from <code class="language-gorillascript">x</code> until exclusive <code class="language-gorillascript">y</code>, stepping by <code class="language-gorillascript">step</code>.</li>
      <li><code class="language-gorillascript">x instanceofsome y</code> - Iterate over array and check with <code class="language-gorillascript">instanceof</code>. Highly efficient if <code class="language-gorillascript">y</code> is a literal array.</li>
      <li><code class="language-gorillascript">x is y</code> - Works like the ECMAScript6 Object.is, which is like GorillaScript&#8217;s <code class="language-gorillascript">==</code>, but differentiating between <code class="language-gorillascript">0</code> and <code class="language-gorillascript">-0</code> and properly comparing <code class="language-gorillascript">NaN is NaN</code>. Not recommended to use unless you know you&#8217;re working with numbers.</li>
      <li><code class="language-gorillascript">x isnt y</code> - Same as <code class="language-gorillascript">not (x is y)</code></li>
      <li><code class="language-gorillascript">x &lt;&lt; y</code> - Compose <code class="language-gorillascript">x</code> and <code class="language-gorillascript">y</code>, like <code class="language-gorillascript">#(...args) -&gt; x(y(...args))</code></li>
      <li><code class="language-gorillascript">x &gt;&gt; y</code> - Compose <code class="language-gorillascript">y</code> and <code class="language-gorillascript">x</code>, like <code class="language-gorillascript">#(...args) -&gt; y(x(...args))</code></li>
      <li><code class="language-gorillascript">x |&gt; f</code> - Pipe <code class="language-gorillascript">x</code> into <code class="language-gorillascript">f</code>, like <code class="language-gorillascript">f(x)</code></li>
      <li><code class="language-gorillascript">f &lt;| x</code> - Pipe <code class="language-gorillascript">x</code> into <code class="language-gorillascript">f</code>, like <code class="language-gorillascript">f(x)</code></li>
      <li><code class="language-gorillascript">x &lt;&lt;&lt; y</code> - Import all properties from <code class="language-gorillascript">y</code> into <code class="language-gorillascript">x</code>, like <code class="language-gorillascript">for k, v of y; x[k] := v</code></li>
      <li><code class="language-gorillascript">x &gt;&gt;&gt; y</code> - Import all properties from <code class="language-gorillascript">x</code> into <code class="language-gorillascript">y</code>, like <code class="language-gorillascript">for k, v of x; y[k] := v</code></li>
    </ul>
  </section>
  
  <section id="function-syntax">
    <h2>Slightly nicer function syntax</h2>

    <p>There are two ways to specify functions, one directly using <code class="language-gorillascript">let</code>, and one as an anonymous function. Also, unlike JavaScript, the last expression is automatically returned (unless tagging the function with <code class="language-gorillascript">!</code>). Functions can be called optionally without parentheses, as long as it is unambiguous.</p>

    <pre class="gs-code"><code class="language-gorillascript">let increment(x)
  x + 1

assert increment(0) == 1
assert (increment 1) == 2
assert 3 == increment 2

let run(callback)
  callback()

assert run(#-&gt; "hello") == "hello"
assert (run #-&gt; "there") == "there"
assert run(#
  "you") == "you"
assert run(#
  let x = "guys"
  "good " &amp; x) == "good guys"

// this syntax also works
let f() -&gt; Math.random()
console.log f()
</code></pre>

    <p>The outer <code class="language-gorillascript">this</code> can also be captured be appending <code class="language-gorillascript">@</code> to the head of the function declaration, creating a &#8220;bound&#8221; function. This is similar to ECMAScript 5&#8217;s <code class="language-gorillascript">Function.prototype.bind</code>, but more efficient since a hidden <code class="language-gorillascript">_this</code> variable is used rather than an extra function call.</p>

    <pre class="gs-code"><code class="language-gorillascript">let func()
  let inner()@
    this

  assert func() == this
</code></pre>
  </section>
  
  <section id="string-interpolation">
    <h2>String interpolation</h2>

    <p>Inside double-quoted strings (<code class="language-gorillascript">"like this"</code>), not single-quoted strings (<code class="language-gorillascript">'like this'</code>), one can specify string interpolations using the <code class="language-gorillascript">$</code> symbol, followed by an identifier or a parenthetical expression.</p>

    <pre class="gs-code"><code class="language-gorillascript">let hello(name)
  "Hello, $name"

assert hello("World") == "Hello, World"
assert hello("Universe") == "Hello, Universe"

// or

let greet(names)
  "Hello, $(names.join ', ')"

assert greet(["World", "Universe"]) == "Hello, World, Universe"
</code></pre>
  </section>

  <section id="optional-parameters">
    <h2>Optional parameters</h2>

    <p>To specify an optional parameter, one simply need to specify <code class="language-gorillascript">= value</code> in the function parameter list.</p>

    <pre class="gs-code"><code class="language-gorillascript">let hello(name = "World")
  "Hello, $name"

assert hello() == "Hello, World"
assert hello("Universe") == "Hello, Universe"
</code></pre>

    <p>If a value is passed in that is null or undefined, it will be automatically turned into the default value.</p>
  </section>
  
  <section id="spread-parameters">
    <h2>Spread parameters</h2>

    <p>Instead of using JavaScript&#8217;s atrociously broken <code class="language-gorillascript">arguments</code> special, one can specify a spread parameter by prefixing <code class="language-gorillascript">...</code>. Only one can occur in a function parameter list, but it can be at any position.</p>

    <pre class="gs-code"><code class="language-gorillascript">let hello(...names)
  if names.length == 0
    "No one is here"
  else
    "Hello, $(names.join ', ')"

hello() == "No one is here"
hello("World") == "Hello, World"
hello("World", "Universe") == "Hello, World, Universe"
</code></pre>

    <p>And so that callers don&#8217;t feel bad about themselves, you can call with spread as well.</p>

    <pre class="gs-code"><code class="language-gorillascript">let f(a, b, c) -&gt; [a, b, c]

let items = [1, 2]

f(0, ...f(...items, 3), 4)
</code></pre>
  </section>
  
  <section id="dashed-identifiers">
    <h2>Dashed-identifiers</h2>

    <p>Although completely optional to use if you prefer using <code class="language-gorillascript">camelScript</code>-style identifiers, one can now specify identifiers with dashes, such as <code class="language-gorillascript">my-name</code> or <code class="language-gorillascript">gorillas-are-awesome</code>. They are turned into <code class="language-gorillascript">myName</code> and <code class="language-gorillascript">gorillasAreAwesome</code>, respectively.</p>

    <pre class="gs-code"><code class="language-gorillascript">let gorillas-are-awesome = "Yes, they are."
</code></pre>
  </section>
  
  <section id="numbers">
    <h2>Nicer number syntax</h2>

    <p>All numbers can have arbitrary underscores in the middle of them, which can be used for thousands separators or bitwise n-bit separators. (<code class="language-gorillascript">1_234_567</code> or <code class="language-gorillascript">0x1234_5678_90ab_cdef</code>)</p>

    <p>Decimal numbers can have inline-comments appended to them after an underscore. (<code class="language-gorillascript">1000_ms</code>)</p>

    <p>Octals use the format <code class="language-gorillascript">0o12345670</code> instead of <code class="language-gorillascript">01234567</code>, to help with clarity.</p>

    <p>Binary numbers are available with the format <code class="language-gorillascript">0b10101010</code>.</p>

    <p>Arbitrary-radix numbers are available by specifying a decimal number between 2 and 36, <code class="language-gorillascript">r</code>, and the number. (<code class="language-gorillascript">4r01230123</code>, <code class="language-gorillascript">36rjdhremn</code>)</p>

    <pre class="gs-code"><code class="language-gorillascript">let time = 10_000_ms
let hex = 0x1234_5678
let octal = 0o070
let binary = 0b1010010101
let radix = 36rNFfdH45
let float = 123_456.789_012
</code></pre>

    <p>Non-decimals do support floating point unlike JavaScript, though that is a lesser-used feature.</p>
  </section>
  
  <section id="strings">
    <h2>Some new string syntaxes</h2>

    <p>Aside from the already-seen string interpolation, there are also triple-quoted strings, which allow for multi-line and are indentation-friendly.</p>

    <pre class="gs-code"><code class="language-gorillascript">let name = "Jimmy"
let string = """
  Hello there.
    I have a story to tell you, $name.
  I can't think of it right now, though.
  """
</code></pre>
    
    <p>The indentation is stripped (but not line 2&#8217;s, since that's deliberate), and interpolation is done for <code class="language-gorillascript">$name</code>, and the first and last newlines are removed. This all occurs at compile-time, so your result code will be as fast as possible.</p>

    <p>There are also string like <code class="language-gorillascript">'''this'''</code> which do not have interpolation, if you wish to use it.</p>

    <p>There is also a short syntax for single-word strings that also convert <code class="language-gorillascript">dashed-names</code> to <code class="language-gorillascript">camelCase</code> just as normal identifiers do.</p>

    <pre class="gs-code"><code class="language-gorillascript">assert "Jimmy" == \Jimmy
assert object.some-key == object[\some-key]
assert "someKey" == \some-key
</code></pre>

    <p>GorillaScript includes all the escape sequences you may be familiar with in JavaScript, such as <code class="language-gorillascript">"\0"</code>, <code class="language-gorillascript">"\t"</code>, <code class="language-gorillascript">"\v"</code>, and many more. You needn&#8217;t worry about some non-standard escape codes such as <code class="language-gorillascript">"\v"</code>, as GorillaScript compiles to the lowest common denominator.</p>
    
    <p>It also includes the <code class="language-gorillascript">\u</code> unicode escape sequence which takes 4 hex characters trailing it and <code class="language-gorillascript">\x</code> which takes 2 hex characters trailing it.</p>
    
    <p>Unlike JavaScript, GorillaScript can properly handle unicode code points greater than <code class="language-gorillascript">0xFFFF</code>, by having the <code class="language-gorillascript">\u{}</code> syntax. Inside the braces, one can put between 1 and 6 hex characters as long as the representation doesn't exceed <code class="language-gorillascript">0x10FFFF</code>. This will be split up into two UTF-16 code points if exceeding <code class="language-gorillascript">0xFFFF</code>.</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let escapes = "\b\f\r\n\t\v\0\1\2\3\4\5\6\7"
let hex = "\xe9"
let unicode = "\u1d25"
let large-unicode = "\u{20bb7}"
assert large-unicode.length == 2 // takes up 2 UTF-16 characters, one Unicode code point
</code></pre>
  </section>
  
  <section id="objects-and-arrays">
    <h2>Nicer syntaxes for objects and arrays</h2>

    <p>Although the standard JavaScript-style syntaxes work, there are a few other ways to specify objects and arrays.</p>

    <pre class="gs-code"><code class="language-gorillascript">let list = [1, 2, 3]
let other-list = [...list, 4, 5, 6] // now contains [1, 2, 3, 4, 5, 6]

// another way to specify an array
let items =
  * "Apples"
  * "Bananas"
  * "Cherries"

let obj = {
  list // same as list: list
  sum: 6
  f() -> "result" // same as f: #() -> "result"
}

let great-apes =
  bonobos:
    awesomeness: "pretty cool"
    population: 40_000
  humans:
    awesomeness: "let's not say anything bad about these guys"
    population: 7_000_000_000
  gorillas:
    awesomeness: "clearly the best"
    population: 100_000

let special = {
  [1 + 2]: "three"
  "key$i": "interpolated key"
  class: "JavaScript would fail on the 'class' key."
}
</code></pre>

    <p>To specify the prototype of an object:</p>

    <pre class="gs-code"><code class="language-gorillascript">let parent = { hello: \there }
let child = { extends parent
  value: 1
}
assert child.hello == \there
assert child.value == 1
</code></pre>
  </section>
  
  <section id="maps-and-sets">
    <h2>First-class support for Maps and Sets</h2>
    
    <p><code class="language-gorillascript">Map</code> and <code class="language-gorillascript">Set</code> are available in the upcoming ECMAScript 6 and in some existing JavaScript engines. There are also shims to provide support in engines that do not support it out-of-the-box.</p>
    
    <p>GorillaScript will automatically provide a shim if used, but it is recommended to use either a native implementation or a more-efficient shim.</p>
    
    <p><code class="language-gorillascript">Map</code> is similar to <code class="language-gorillascript">Object</code>, except its keys are not required to be <code class="language-gorillascript">String</code>s, but can be any type. Also, access and assignment is done through method calls rather than raw dot-access.</p>
    
    <p><code class="language-gorillascript">Set</code> is a collection of unique values, similar to a <code class="language-gorillascript">Map</code> where all values are <code class="language-gorillascript">true</code>.</p>
    
    <p>GorillaScript has syntax for declaring both of these as literals, just as one can do with <code class="language-gorillascript">Array</code>s or <code class="language-gorillascript">Object</code>s.</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let obj = {}
let other = {}
let map = %{
  [obj]: 1
  [other]: "hello"
}
assert map.get(obj) == 1
assert map.get(other) == "hello"
map.delete other
assert map.has obj
assert not map.has other
map.set other, "there"
assert map.has other
assert map.get(other) == "there"

let set = %[obj, other]
assert set.has(obj)
assert set.has(other)
set.delete(other)
assert not set.has(other)
set.add other
assert set.has(other)
set.add other // does nothing, already in the set.
</code></pre>
  </section>

  <section id="unless">
    <h2>Unless statement</h2>

    <p>To correlate with the <code class="language-gorillascript">if</code> statement, there is also an <code class="language-gorillascript">unless</code> statement which works as its exact opposite.</p>

    <pre class="gs-code"><code class="language-gorillascript">if hates-bananas
  "You monster."
else unless loves-gorillas
  "How could you?"
else if likes-the-gorillaz
  "Fire comes out of the monkey's head."
else
  "Well, at least you love gorillas and don't hate bananas."
</code></pre>
  </section>

  <section id="loops">
    <h2>Loops</h2>

    <p>GorillaScript provides many different looping constructs, all fitted for their own purposes.</p>

    <p>Normal while loop, same as JavaScript:</p>

    <pre class="gs-code"><code class="language-gorillascript">let mutable i = 0
while i &lt; 10
  console.log i
  i += 1
</code></pre>

    <p>Opposite of a while loop, <code class="language-gorillascript">until</code>:</p>

    <pre class="gs-code"><code class="language-gorillascript">let mutable i = 0
until i &gt;= 10
  console.log i
  i += 1
</code></pre>

    <p>Better version of the above, acts like JavaScript&#8217;s for(;;)</p>

    <pre class="gs-code"><code class="language-gorillascript">let mutable i = 0
while i &lt; 10, i += 1
  console.log i
</code></pre>

    <p>Even better version:</p>

    <pre class="gs-code"><code class="language-gorillascript">for i in 0 til 10
  console.log i
</code></pre>

    <p>Or if you want to go in reverse,</p>

    <pre class="gs-code"><code class="language-gorillascript">for i in 9 to 0 by -1
  console.log i
</code></pre>

    <p>Or by twos:</p>

    <pre class="gs-code"><code class="language-gorillascript">for i in 0 til 10 by 2
  console.log i
</code></pre>

    <p>You don&#8217;t have to use literal numbers, they can be any expression in GorillaScript. You can also use <code class="language-gorillascript">to</code>, <code class="language-gorillascript">til</code>, and <code class="language-gorillascript">by</code> to make arrays outside of loops.</p>

    <p>The difference between <code class="language-gorillascript">til</code> and <code class="language-gorillascript">to</code> is that <code class="language-gorillascript">til</code> goes up until it hits the end, but <code class="language-gorillascript">to</code> includes the end.</p>

    <p>To iterate over an array,</p>

    <pre class="gs-code"><code class="language-gorillascript">for food in ["Apples", "Bananas", "Cherries"]
  console.log food
</code></pre>

    <p>If you want its index,</p>

    <pre class="gs-code"><code class="language-gorillascript">for food, index in ["Apples", "Bananas", "Cherries"]
  console.log "$index: $food"
</code></pre>

    <p>You can also get the total length of the array, if you need it:</p>

    <pre class="gs-code"><code class="language-gorillascript">for value, index, length in some-array
  f()
</code></pre>

    <p>To iterate an array in reverse (slightly more efficient):</p>

    <pre class="gs-code"><code class="language-gorillascript">for value, index in some-array by -1
  // index goes from some-array.length - 1 down to 0.
  console.log value
</code></pre>

    <p>To iterate only a part of the array:</p>

    <pre class="gs-code"><code class="language-gorillascript">for value in some-array[2 to 5]
  console.log value
</code></pre>

    <p>It works similarly to some-array.slice(2, 6). You can slice outside of loops as well.</p>

    <p>To iterate over objects, you can use <code class="language-gorillascript">of</code> instead of <code class="language-gorillascript">in</code>:</p>

    <pre class="gs-code"><code class="language-gorillascript">for key, value of some-object
  console.log key, value
</code></pre>

    <p>GorillaScript automatically runs an Object.prototype.hasOwnProperty check on the key. To avoid this, use:</p>

    <pre class="gs-code"><code class="language-gorillascript">for key, value ofall some-object
  console.log key, value
</code></pre>

    <p>Any loop can be an expression simply by returning it or assigning it to a variable. This will create an array.</p>

    <pre class="gs-code"><code class="language-gorillascript">let squares = for value in 0 to 10
  value ^ 2

// squares now contains [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>

    <p>Single-line loops can be specified as so:</p>

    <pre class="gs-code"><code class="language-gorillascript">let squares = for value in 0 to 10; value ^ 2
</code></pre>

    <p>There are also reducing loops which work by placing one of the reducers (<code class="language-gorillascript">first</code>, <code class="language-gorillascript">every</code>, <code class="language-gorillascript">some</code>, <code class="language-gorillascript">filter</code>, <code class="language-gorillascript">reduce</code>) on the <code class="language-gorillascript">for</code> or <code class="language-gorillascript">while</code> loop.</p>

    <pre class="gs-code"><code class="language-gorillascript">let all-good = for every item in array; item.is-good()
let has-bad = for some item in array; item.is-bad()
let best-value = for first item in array
  if item.is-best()
    item.value
let only-good = for filter item in array; item.is-good()
let sum = for reduce value in [0, 1, 2, 3, 4], current = 0
  current + value
</code></pre>

    <p>These work on any <code class="language-gorillascript">for</code> or <code class="language-gorillascript">while</code> loop.</p>
  </section>

  <section id="lexical-scope">
    <h2>Lexical scoping in loops</h2>

    <p>A common bug in JavaScript is when one creates a function inside a loop that refers to the current index or value or some other variable that changes each loop iteration. GorillaScript solves this problem by wrapping any for loop that creates a function in another function, so the following works by seemingly lexically-scoping the inside of the for loop rather than abiding by JavaScript&#8217;s normal function scoping.</p>

    <pre class="gs-code"><code class="language-gorillascript">let funcs = []
for i in 0 til 10
  funcs.push #-&gt; i

funcs[0]() == 0
funcs[5]() == 5
</code></pre>

    <p>With no extra work on the developer&#8217;s part.</p>
  </section>
  
  <section id="array-slicing">
    <h2>Array slicing</h2>

    <p>As mentioned briefly earlier, one can use the <code class="language-gorillascript">to</code>, <code class="language-gorillascript">til</code>, and <code class="language-gorillascript">by</code> syntaxes to slice on arrays.</p>

    <pre class="gs-code"><code class="language-gorillascript">let array = [\a, \b, \c, \d, \e]
assert-arr array[1 to 3], [\a, \b, \c]
assert-arr array[1 to 5 by 2], [\a, \c, \e]
assert-arr array[5 to 1 by -2], [\e, \c, \a]
assert-arr array by -1, [\e, \d, \c, \b, \a]
assert-arr array[0 to -1], [\a, \b, \c, \d, \e]
assert-arr array[0 to Infinity], [\a, \b, \c, \d, \e]
</code></pre>

    <p>The negative values work just as they do in <code class="language-gorillascript">.slice</code>, unlike normal accessing</p>
  </section>
  
  <section id="array-negative-index">
    <h2>Array negative indexing</h2>

    <p>GorillaScript can&#8217;t wrap every single access in a check to see if the child is a negative value (as Python or some other languages do), due to efficiency, but it does provide a nice syntax to make it easier.</p>

    <pre class="gs-code"><code class="language-gorillascript">let array = [\a, \b, \c, \d, \e]
assert array[* - 1] == \e
assert array[* - 2] == \d
assert array[* \ 2] == \c // halfway point in the array
</code></pre>

    <p>When a standalone <code class="language-gorillascript">*</code> is encountered in an index, it is converted to the current array&#8217;s <code class="language-gorillascript">.length</code>.</p>
  </section>
  
  <section id="expressions">
    <h2>Everything is an expression (mostly)</h2>

    <p>Unlike JavaScript, <code class="language-gorillascript">for</code> loops, <code class="language-gorillascript">while</code> loops, <code class="language-gorillascript">try</code> blocks, and <code class="language-gorillascript">if</code> constructs can be used as expressions.</p>

    <pre class="gs-code"><code class="language-gorillascript">let array = for i in 0 to 10; i
let trial = try
  throw Error()
catch e
  "Caught something"
assert trial == "Caught something"
let check = if youre-amazing
  "It's true"
else
  "Not amazing."
</code></pre>
  </section>
  
  <section id="existential">
    <h2>Existential operator</h2>

    <p>If one wishes to check a value against null or undefined, the existential operator (<code class="language-gorillascript">?</code>) can be used.</p>

    <pre class="gs-code"><code class="language-gorillascript">let exists = value?
</code></pre>

    <p>It can also be used for access soaking</p>

    <pre class="gs-code"><code class="language-gorillascript">let inner = value?.which.might?.not.exist
</code></pre>

    <p>Turns into</p>

    <pre class="gs-code"><code class="language-gorillascript">let inner = if value?
  let _ref = value.which.might
  if _ref?
    _ref.not.exist
</code></pre>

    <p>It can also be used for function checking</p>

    <pre class="gs-code"><code class="language-gorillascript">let result = f?()
</code></pre>

    <p>Turns into</p>

    <pre class="gs-code"><code class="language-gorillascript">let result = if typeof f == \function
  f()
</code></pre>
  </section>
  
  <section id="in">
    <h2><code>in</code> operator</h2>

    <p>To correlate with array iteration, <code class="language-gorillascript">in</code> checks if a value is in an array, in a similar way to <code class="language-gorillascript">array.indexOf(value) != -1</code> would.</p>

    <pre class="gs-code"><code class="language-gorillascript">assert \hello in [\hi, \there, \hello]
</code></pre>

    <p>To check if an object contains a key, see the <code class="language-gorillascript">haskey</code> operator.</p>
  </section>
  
  <section id="haskey-ownskey">
    <h2><code>haskey</code> and <code>ownskey</code></h2>

    <p>Instead of using JavaScript&#8217;s <code class="language-gorillascript">in</code>, <code class="language-gorillascript">haskey</code> is used to verify a key&#8217;s existence on an object. Also, <code class="language-gorillascript">ownskey</code> is also available to check if a key exists on an object without prototype-checking.</p>

    <pre class="gs-code"><code class="language-gorillascript">let parent = { alpha: \bravo }
let child = { extends parent, charlie: \delta }

assert parent haskey \alpha
assert parent ownskey \alpha
assert parent not haskey \charlie
assert parent not ownskey \charlie
assert child haskey \alpha
assert child not ownskey \alpha
assert child haskey \charlie
assert child ownskey \charlie
</code></pre>
  </section>
  
  <section id="ownership">
    <h2>Access with ownership</h2>

    <p>Sometimes you may have an object where you want to access its key but only in the case of the object owning the key as a property.</p>

    <pre class="gs-code"><code class="language-gorillascript">assert if parent ownskey key
  parent[key]

// functionally equivalent to

assert parent![key]
</code></pre>

    <p>Or, for a known key:</p>

    <pre class="gs-code"><code class="language-gorillascript">assert if parent ownskey \key
  parent.key

assert parent!.key
</code></pre>
  </section>
  
  <section id="apply">
    <h2>Apply syntax</h2>

    <p>In JavaScript, if you wish to specify the <code class="language-gorillascript">this</code> argument passed to a function, one must use either <code class="language-gorillascript">.call</code> or <code class="language-gorillascript">.apply</code>. GorillaScript provides the <code class="language-gorillascript">@</code> syntax:</p>

    <pre class="gs-code"><code class="language-gorillascript">let f() -&gt; this

let obj = {}
assert obj == f@ obj
assert obj == f@(obj)

Array.prototype.slice@ arguments, 1
</code></pre>

    <p>It transparently converts to <code class="language-gorillascript">.call</code> or <code class="language-gorillascript">.apply</code> (whichever is more appropriate), using the first argument as its <code class="language-gorillascript">this</code>.</p>
  </section>
  
  <section id="bind">
    <h2>Binding access</h2>

    <p>ECMAScript 5 supplies <code class="language-gorillascript">Function.prototype.bind</code> as a way to bind functions to a specific this (and specify arguments). To do a similar binding in GorillaScript, one need only use the familiar <code class="language-gorillascript">@</code> syntax with access.</p>

    <pre class="gs-code"><code class="language-gorillascript">let obj = {
  f: # -&gt; this
}

let bound = obj@.f
assert bound() == obj
let unbound = obj.f
assert unbound() == window
</code></pre>
  </section>

  <section id="classes">
    <h2>Classes</h2>

    <p>GorillaScript provides a way to make classical-style classes. JavaScript does not have classes normally, so GorillaScript&#8217;s creation is slightly hackish, but works for the general case.</p>

    <pre class="gs-code"><code class="language-gorillascript">class Animal
  def constructor(@name) -&gt;

  def eat() -&gt; "$(@name) eats"

class GreatApe extends Animal
  // no constructor, Animal's is automatically called
  def eat(food="fruit") -&gt; super.eat() &amp; " a " &amp; food

class Gorilla extends GreatApe
  def constructor(@name, @favorite-food)
    // important to call the super constructor.
    super(@name)

  def eat() -&gt; super.eat(@favorite-food)

class Chimp extends GreatApe
  def eat() -&gt; super.eat("banana")

let bobo = Chimp("Bobo") // new is not required on GorillaScript-made classes
assert bobo.eat() == "Bobo eats a banana"

let toko = Gorilla("Toko", "cherry")
assert toko.eat() == "Toko eats a cherry"

// set a method on the Gorilla constructor
Gorilla::barrel := # -&gt; @name &amp; " throws a barrel!"

assert toko.barrel() == "Toko throws a barrel!"
</code></pre>

    <p>Classes can <code class="language-gorillascript">extend</code> other classes and call into their superclass with <code class="language-gorillascript">super</code>. The constructor functions automatically check the <code class="language-gorillascript">this</code> argument and if it is not the current class&#8217;s type (such as when called without <code class="language-gorillascript">new</code>), it will create a new one on-the-fly.</p>
  </section>
  
  <section id="destructuring">
    <h2>Destructuring</h2>

    <p>GorillaScript, like ECMAScript 6, provides a destructuring declaration.</p>

    <pre class="gs-code"><code class="language-gorillascript">let [x, y] = [1, 2]
assert x == 1
assert y == 2

let {a, b: c} = {a: 3, b: 4}
assert a == 3
assert c == 4
</code></pre>

    <p>These can be nested like so:</p>

    <pre class="gs-code"><code class="language-gorillascript">let [a, {b, c: [d]}] = get-data()
</code></pre>

    <p>And the spread operator (<code class="language-gorillascript">...</code>) can be used once per array destructure:</p>

    <pre class="gs-code"><code class="language-gorillascript">let [value, ...rest] = array
</code></pre>
  </section>
  
  <section id="switch">
    <h2>Switch</h2>

    <p>Like JavaScript, GorillaScript provides <code class="language-gorillascript">switch</code>. The only major exception is that JavaScript is fallthrough-by-default, and GorillaScript is break-by-default. GorillaScript can also specify multiple values to check at once instead of having multiple cases. <code class="language-gorillascript">switch</code> can also be used as an expression.</p>

    <pre class="gs-code"><code class="language-gorillascript">switch value
case 0, 1, 2
  "small"
case 3, 4, 5
  fallthrough // in the last position of the case, causes the case to fall through to the next case.
case 6, 7, 8
  "large"
default
  "unknown"
</code></pre>

    <p>Unlike JavaScript, GorillaScript provides a topicless <code class="language-gorillascript">switch</code>, which works by checking if each case is truthy rather than comparing against a value. <code class="language-gorillascript">fallthrough</code> works the same way as a normal switch statement. This does not generate a JavaScript <code class="language-gorillascript">switch</code> statement, as it is extremely inefficient to use <code class="language-gorillascript">switch</code> in JavaScript without constant <code class="language-gorillascript">case</code> checks.</p>

    <pre class="gs-code"><code class="language-gorillascript">switch
case is-good()
  "good"
case is-bad()
  "bad"
default
  "neutral"
</code></pre>
  </section>

  <section id="try-catch">
    <h2>Try-catch-else-finally</h2>

    <p>Try-catch also works similarly to JavaScript, except that catches can have type-checks and the notable exception of the <code class="language-gorillascript">else</code> statement, for when no error was caught, but occurs before the <code class="language-gorillascript">finally</code> statement.</p>

    <pre class="gs-code"><code class="language-gorillascript">try
  something-dangerous()
catch e as SpecificError
  handle-error(e)
catch e
  uh-oh()
else
  whew()
finally
  cleanup()
</code></pre>

    <p>At least one of <code class="language-gorillascript">catch</code>, <code class="language-gorillascript">else</code>, or <code class="language-gorillascript">finally</code> must be used, but so can all three.</p>
  </section>
  
  <section id="regexes">
    <h2>Regular Expressions</h2>

    <p>Unlike JavaScript, Regular Expressions borrow the string syntax simply prefixed with <code class="language-gorillascript">r</code> and postfixed with any RegExp flags deemed necessary. Also, if triple-quoted strings (e.g. <code class="language-gorillascript">r"""reg"""g</code>) are used, all spaces are ignored as well as any <code class="language-gorillascript"># hash comments</code></p>

    <pre class="gs-code"><code class="language-gorillascript">r"l".test "apple"
let regex = r"""
  This is a large regex, $name
  And all the space is ignored # and this is ignored, too!
  """gim
</code></pre>
  </section>

  <section id="custom-interpolation">
    <h2>Custom interpolation strings</h2>

    <p>If one doesn&#8217;t wish to use simple string concatenation with string interpolation, <code class="language-gorillascript">%</code> can be prefixed to any double-quoted string to return an array instead which can then be interpolated in a custom manner. All even-numbered strings are guaranteed to be source literals and all odd-numbered values (might not be strings) are interpolated input.</p>

    <p>The following is an example of automatic HTML escaping, but the same concept could be applied to SQL strings or practically any string with unsafe input.</p>

    <pre class="gs-code"><code class="language-gorillascript">class SafeHTML
  def constructor(@text as String) -&gt;
  def to-string() -&gt; @text
let to-HTML = do
  let escapes = {
    "&amp;": "&amp;amp;"
    "&lt;": "&amp;lt;"
    "&gt;": "&amp;gt;"
    '"': "&amp;quot;"
    "'": "&amp;#39;"
  }
  let replacer(x) -&gt; escapes[x]
  let regex = r"[&amp;&lt;&gt;""']"g
  let escape(text) -&gt; text.replace(regex, replacer)
  #(arr)
    (for x, i in arr
      if i %% 2 or x instanceof SafeHTML
        x
      else
        escape String(x)).join ""

assert "&lt;h1&gt;normal&lt;/h1&gt;" == to-HTML %"&lt;h1&gt;normal&lt;/h1&gt;"
let evil-name = "&lt;\"bob\" the 'great' &amp; powerful&gt;"
assert "&amp;lt;&amp;quot;bob&amp;quot; the &amp;#39;great&amp;#39; &amp;amp; powerful&amp;gt;" == to-HTML %"$evil-name"
assert "&lt;span&gt;&amp;lt;&amp;quot;bob&amp;quot; the &amp;#39;great&amp;#39; &amp;amp; powerful&amp;gt;&lt;/span&gt;" == to-HTML %"&lt;span&gt;$evil-name&lt;/span&gt;"
assert "&lt;span&gt;&lt;\"bob\" the 'great' &amp; powerful&gt;&lt;/span&gt;" == to-HTML %"&lt;span&gt;$(SafeHTML evil-name)&lt;/span&gt;"
</code></pre>
  </section>

  <section id="iterators">
    <h2>Iterators</h2>

    <p>Iterators are an ECMAScript 6 feature that have been in Mozilla&#8217;s JavaScript since 1.7. GorillaScript can both produce and consume such iterators. The API used is specified in the <a href="https://github.com/rwldrn/tc39-notes/blob/master/es6/2013-03/mar-12.md#412-stopiterationgenerator">TC39 March 2013 notes</a></p>

    <pre class="gs-code"><code class="language-gorillascript">for value, index from some-iterable
  console.log value
</code></pre>

    <p>Turns into the following code:</p>

    <pre class="gs-code"><code class="language-gorillascript">let _iter = some-iterable.iterator()
let mutable index = 0
try
  while true, index += 1
    let _item = _iter.next()
    if _item.done
      break
    let value = _item.value
    console.log value
finally
  try
    _iter.close()
  catch e
    void
</code></pre>

    <p>Which means that any object that implements the <code class="language-gorillascript">iterator</code> method acts as an iterable. That return value merely needs to implement the <code class="language-gorillascript">next</code> method.</p>

    <p>If <code class="language-gorillascript">Array.prototype</code> were to implement <code class="language-gorillascript">iterator</code>, which the ECMAScript 6 draft is recommending, one could iterate over <code class="language-gorillascript">Array</code>s, <code class="language-gorillascript">Set</code>s, <code class="language-gorillascript">Map</code>s, but one can iterate over any custom type now or by simply adding an <code class="language-gorillascript">Array.prototype.iterator</code> method.</p>

    <p>Production of iterators is easy as well in GorillaScript. You need merely append the <code class="language-gorillascript">*</code> and use the <code class="language-gorillascript">yield</code> statement.</p>

    <pre class="gs-code"><code class="language-gorillascript">let fib()*
  let mutable a = 0
  let mutable b = 1
  while true
    yield b
    let tmp = a
    a := b
    b += tmp
</code></pre>

    <p>Produces an iterable which returns the infinite sequence of fibonacci numbers. The resultant code looks something along the lines of:</p>

    <pre class="gs-code"><code class="language-gorillascript">let fib()
  let mutable a = 0
  let mutable b = 1
  let mutable _state = 0
  {
    iterator: #-&gt; this
    next: #
      while true
        switch _state
        case 0
          _state := 1
          return { -done, value: b }
        case 1
          let tmp = a
          a := b
          b += tmp
          _state := 0
  }
</code></pre>

    <p>The state machine is made for you and any GorillaScript construct can be used inside a generator function.</p>

    <p>One could then easily then use the fib iterator:</p>

    <pre class="gs-code"><code class="language-gorillascript">for value from fib()
  console.log value
  if value &gt; 4000000
    break
</code></pre>
    
    <p>One can also use <code class="language-gorillascript">yield</code> in an expression position, not just <code class="language-gorillascript">return</code> as a way to receive information from custom iterators. This isn&#8217;t affected by a <code class="language-gorillascript">for-from</code> loop, but some libraries and patterns can rely on it.</p>
  </section>

  <section id="async">
    <h2>Async</h2>

    <p>GorillaScript provides a whole slew of asynchronous-capable syntax to make dealing with &#8220;callback hell&#8221; just a little easier. Since JavaScript fundamentals and frameworks (node.js, for example) tend to be very async-friendly, this is especially helpful.</p>

    <h3>Calling an async function</h3>

    <pre class="gs-code"><code class="language-gorillascript">async err, text &lt;- fs.read-file "somefile.txt", "utf8"
throw? err
console.log text
</code></pre>

    <p>No indentation necessary, every line following the async call will be part of the implicitly-constructed callback. The resultant code looks like:</p>

    <pre class="gs-code"><code class="language-gorillascript">fs.read-file "somefile.txt", "utf8", #(err, text)@
  throw? err
  console.log text
</code></pre>

    <p>Although that may not seem too useful with only one block of indentation, when dealing with complex database access or multiple sources of input, it is very easy to become overwhelmed.</p>

    <h3>Async function with automatic error handling</h3>

    <p>In the case where you don&#8217;t want to throw the error, but instead need to pass it to a callback (which takes the error as the first argument), you have one of two options:</p>

    <pre class="gs-code"><code class="language-gorillascript">let run(callback)
  async err, text &lt;- fs.read-file "somefile.txt", "utf8"
  if err?
    return callback err
  callback null, do-something(text)
</code></pre>

    <p>Or you can use</p>

    <pre class="gs-code"><code class="language-gorillascript">let run(callback)
  async! callback, text &lt;- fs.read-file "somefile.txt", "utf8"
  callback null, do-something(text)
</code></pre>

    <p>Which is functionally equivalent.</p>

    <h3>Async loops</h3>

    <p>Often, one may use a library to manage asynchronous handling of loops and iteration over arrays, but that is all built right into GorillaScript. Every loop construct you&#8217;ve seen works seamlessly by prepending <code class="language-gorillascript">async</code> and specifying the <code class="language-gorillascript">next</code> callback.</p>

    <p>The <code class="language-gorillascript">next</code> callback expects 0 to 2 arguments, if it receives a non-<code class="language-gorillascript">null</code>-or-<code class="language-gorillascript">undefined</code> value as its first argument, it will halt the loop immediately, as an error or other break has occurred. If it receives a second argument, it will append that value to an array, which may be optionally requested by the developer.</p>

    <p><code class="language-gorillascript">asyncfor</code> loops can specify their level of parallelism manually (defaulting to <code class="language-gorillascript">1</code>, which runs serially). If parallelism is set to <code class="language-gorillascript">0</code>, it runs completely parallel.</p>

    <pre class="gs-code"><code class="language-gorillascript">// read two files at a time
asyncfor(2) err, array &lt;- next, filename in ["a.txt", "b.txt", "c.txt", "d.txt"]
  async err, text &lt;- fs.read-file filename, "utf8"
  if err?
    // if an error occurs, it propagates up and no more files will be read, and post-async execution
    // will occur immediately.
    return next err
  next null, { filename, text }
throw? err
console.log array // array will now be filled with objects like { filename: "a.txt", text: "lots of text here" }
</code></pre>

    <p>Which turns into a device which looks something like:</p>

    <pre class="gs-code"><code class="language-gorillascript">let _array = ["a.txt", "b.txt", "c.txt", "d.txt"]
__async-result 2, array.length,
  #(i, next)@
    let filename = array[i]
    fs.read-file filename, "utf8", #(err, text)@
      if err?
        return next err
      next null, { filename, text }
  #(err, array)@
    throw? err
    console.log array
</code></pre>

    <p>There is also <code class="language-gorillascript">asyncwhile</code> and <code class="language-gorillascript">asyncuntil</code>, which work similarly to their normal constructs but require the <code class="language-gorillascript">next</code> argument to inform the code that its execution has completed one way or another.</p>

    <h3>Async conditionals</h3>

    <p>If you wish to use conditionals which may or may not have asynchronous code inside their bodies, <code class="language-gorillascript">asyncif</code> or <code class="language-gorillascript">asyncunless</code> is necessary.</p>

    <pre class="gs-code"><code class="language-gorillascript">asyncif text &lt;- next, some-boolean()
  async err, text &lt;- fs.read-file filename, "utf8"
  throw? err
  next(text)
// else is optional, will automatically call next() if not provided
console.log text
</code></pre>

    <p>Which turns into something like:</p>

    <pre class="gs-code"><code class="language-gorillascript">let next(text)
  console.log text
if some-boolean()
  fs.read-file filename, "utf8", #(err, text)@
    throw? err
    next(text)
else
  next()
</code></pre>

    <h3>Returning</h3>

    <p>Occasionally, one needs to return a value such as <code class="language-gorillascript">false</code> in an event handler, while using an asynchronous command. This is where the <code class="language-gorillascript">returning</code> statement comes in. It works just like <code class="language-gorillascript">return</code>, only it runs at the end of its block rather than where it is placed.</p>

    <pre class="gs-code"><code class="language-gorillascript">register-event #(filename)
  returning false
  async err, text &lt;- fs.read-file filename, "utf8"
  throw? err
  console.log text
</code></pre>

    <p>Which turns into:</p>

    <pre class="gs-code"><code class="language-gorillascript">register-event #(filename)
  fs.read-file filename, "utf8", #(err, text)
    throw? err
    console.log
  return false
</code></pre>
  </section>
  
  <section id="promises">
    <h2>Promises</h2>
    
    <p>GorillaScript provides mechanisms for <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a>-compliant promises to be used and joined and manipulated together.</p>
    
    <p>Promises have the benefit over simple callbacks in that they are well-defined by the Promises/A+ spec, have easy-to-follow resolve/reject rules, and can be combined together shockingly easily.</p>
    
    <p>Piggy-backing on the <code class="language-gorillascript">yield</code> syntax, since <code class="language-gorillascript">yield</code> can be used as an expression and not just a statement, information can be sent back to the iterator every time a <code class="language-gorillascript">yield</code> occurs. GorillaScript takes advantage of this with the <code class="language-gorillascript">promise!</code> keyword, which converts a generator function into a promise factory or allows an arbitrary block of code to turn into a promise, all one needs to do is <code class="language-gorillascript">yield</code> other promises until complete.</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let make-promise = promise! #(filename)*
  // here, read-file returns a promise
  let text = yield read-file(filename)
  return text.to-upper-case()

let promise = make-promise()
  .then(on-success, on-failure)
</code></pre>

    <p>It practically reads like synchronous code, and it's guaranteed to execute in the same order as if it were synchronous.</p>
    
    <p>You can also use <code class="language-gorillascript">promise!</code> with a body of code instead of just a function:</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let do-stuff(filename)
  let my-promise = promise!
    let text = yield read-file(filename)
    return text.to-upper-case()
  
  my-promise.then(on-success, on-failure)
</code></pre>

    <p>To facilitate the easy use of promises, there is also a <code class="language-gorillascript">to-promise!</code> macro that converts a normal function call into a self-fulfilled promise, as long as that function takes a callback as its last argument with the signature <code class="language-gorillascript">function (error, result)</code>.</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let do-stuff(filename)
  let my-promise = promise!
    let p = to-promise! fs.read-file filename, "utf8"
    let text = yield p
    return text.to-upper-case()
  
  my-promise.then(on-success, on-failure)
</code></pre>
  </section>

  <section id="typing">
    <h2>Optional typing</h2>

    <p>On parameters, one can put types in the format <code class="language-gorillascript">param as Type</code>. These will be checked at runtime and the type inference engine will be aware of them.</p>

    <p>The types <code class="language-gorillascript">String</code>, <code class="language-gorillascript">Number</code>, <code class="language-gorillascript">Boolean</code>, and <code class="language-gorillascript">Function</code> will check against <code class="language-gorillascript">typeof</code>, not with <code class="language-gorillascript">instanceof</code>.</p>

    <p><code class="language-gorillascript">null</code>, <code class="language-gorillascript">void</code>, and <code class="language-gorillascript">undefined</code> (alias for <code class="language-gorillascript">void</code>) are also seen as valid types.</p>

    <p>Arrays can be made using the syntax of <code class="language-gorillascript">[]</code> for an array of any type or <code class="language-gorillascript">[Type]</code> for a specific array. The contents will be checked at runtime.</p>

    <p>Objects can be made using the standard object syntax with all values being types, e.g. <code class="language-gorillascript">{x: Number, y: String}</code></p>

    <p>Functions with specific parameters or return value can be defined with <code class="language-gorillascript">-&gt;</code> for any parameter, any return. <code class="language-gorillascript">-&gt; Type</code> for a specific return value, <code class="language-gorillascript">Type -&gt; Type</code> for a single-argument with a specific return value, or <code class="language-gorillascript">(Type, Type) -&gt; Type</code> for two arguments with a specific return value.</p>

    <p>Type unions can be made with <code class="language-gorillascript">|</code>, e.g. <code class="language-gorillascript">Number|String</code>. Order is irrelevant.</p>

    <p>One can also place a return type on functions, which is not checked at runtime, but is used by the type inference engine.</p>

    <p>Some examples:</p>

    <pre class="gs-code"><code class="language-gorillascript">let increment(x as Number) -&gt; x + 1
let greet(x as String|Number) -&gt; "Hello, $x"
let run(x as -&gt; Number) -&gt; x()
let get-number() as Number -&gt; num
let join(x as [String]) -&gt; x.join ", "
let use-object(o as {x: Number, y: Number}) -&gt; o.x + o.y
</code></pre>

    <p>Types can also be placed on let statements, to help with the type inference engine.</p>

    <pre class="gs-code"><code class="language-gorillascript">let x as Number = f()</code></pre>
  </section>

  <section id="operators-as-functions">
    <h2>Operators, accesses, and method calls as functions</h2>

    <p>In functional programming, it is often handy to use one of the built-in operators as a function, and GorillaScript provides this capability.</p>

    <pre class="gs-code"><code class="language-gorillascript">let add = (+) // same as #(x, y) -&gt; x + y
assert add(5, 6) == 11

let square = (^ 2) // same as #(x) -&gt; x ^ 2
assert square(10) == 100

let double = (2 *) // same as #(x) -&gt; 2 * x
assert double(5) == 10

let invert = (not) // same as #(x) -&gt; not x
assert invert(true) == false
assert invert(false) == true

assert 10 == [1, 2, 3, 4].reduce (+)
</code></pre>

    <p>Any binary operator can be used this way, and any unary operator can be used as long as it does not share the same token as a binary operator.</p>

    <p>One can also use the same syntax for accesses and method calls</p>

    <pre class="gs-code"><code class="language-gorillascript">let get-length = (.length) // same as #(x) -&gt; x.length
assert get-length("hello") == 5

let to-hex = (.to-string(16)) // same as #(x) -&gt; x.to-string(16)
assert to-hex(255) == "ff"
</code></pre>
  </section>

  <section id="properties">
    <h2>Getters and setters</h2>

    <p>Getter and setter support is up to the engine to support, and is therefore not recommended to be used in the general case. Even Internet Explorer 8 only provides support if the object is a DOM Element, so I cannot recommend using them on a broad scale unless you control the JavaScript engine (such as in node.js).</p>

    <p>There are two ways to define getters and setters:</p>

    <pre class="gs-code"><code class="language-gorillascript">let obj =
  _x: 0
  get x: # -&gt; @_x
  set x: #(value)! -&gt; @_x := value

  _y: 0
  property y:
    get: #-&gt; @_y
    set: #(value)! -&gt; @_y := value
    configurable: true
    enumerable: true
</code></pre>

    <p>When using the <code class="language-gorillascript">get</code> and <code class="language-gorillascript">set</code> pair, they must be defined next to each other (order is irrelevant). One can also supply only <code class="language-gorillascript">get</code> or only <code class="language-gorillascript">set</code>.</p>

    <p>When using the <code class="language-gorillascript">property</code> syntax, the value is the same as one calling <code class="language-gorillascript">Object.defineProperty</code>, in fact, that is all that is happening behind the scenes.</p>
    
    <p>If <code class="language-gorillascript">Object.defineProperty</code> is not available, then it will try to sanely fallback, but it might not be successful. If specifying <code class="language-gorillascript">value</code> instead of <code class="language-gorillascript">get</code>/<code class="language-gorillascript">set</code>, it will always work, but the <code class="language-gorillascript">configurable</code>/<code class="language-gorillascript">enumerable</code>/<code class="language-gorillascript">writable</code> attributes are not guaranteed.</p>

    <p><strong>Note: this might throw an <code class="language-gorillascript">Exception</code> at runtime if specifying <code class="language-gorillascript">get</code>/<code class="language-gorillascript">set</code> and the engine does not support getters/setters. If always using <code class="language-gorillascript">value</code>, this will not fail, even if <code class="language-gorillascript">Object.defineProperty</code> is not defined.</strong></p>
  </section>

  <section id="labels">
    <h2>Labels and <code>break</code>/<code>continue</code></h2>

    <p>JavaScript provides a way to add a label to a block and then be able to <code class="language-gorillascript">break</code> or <code class="language-gorillascript">continue</code> (if it is a loop) on that block.</p>

    <p>Although it is not recommended practice, as one is probably better served by rethinking the algorithm, GorillaScript does provide the capability.</p>

    <pre class="gs-code"><code class="language-gorillascript">let mutable sum = 0
label! outer for i in 0 to 10
  for j in 0 to 10
    if i == j
      continue outer
    sum += i
</code></pre>

    <p>As you can see, the outer loop has the label <code class="language-gorillascript">outer</code> on it and the <code class="language-gorillascript">continue</code> also references that same label, meaning it will continue on the outer loop rather than the inner.</p>
  </section>

  <section id="global">
    <h2>The <code>GLOBAL</code> identifier</h2>

    <p>Since JavaScript can be run outside the browser now, one cannot rely on <code class="language-gorillascript">window</code> always being the global object, so GorillaScript provides the <code class="language-gorillascript">GLOBAL</code> identifier for just this case, which will be <code class="language-gorillascript">window</code> or <code class="language-gorillascript">global</code> or the outermost <code class="language-gorillascript">this</code>, whichever one works best. It is UPPER-CASE and therefore loud for a reason: try to avoid globals when possible.</p>

    <pre class="gs-code"><code class="language-gorillascript">assert Math == GLOBAL.Math
</code></pre>
  </section>
  
  <section id="curry">
    <h2>Curried functions</h2>
    
    <p>Currying is a technique of transforming a function which takes multiple arguments in such a way that it can be called as a chain of functions. GorillaScript provides a nice way to automatically curry functions.</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let add(a, b, c)^
  a + b + c

assert add(1, 2, 3) == 6 // same as before
let add-one = add 1
assert add-one(2, 3) == 6
let add-two = add 2
assert add-two(1, 3) == 6
let add-one-and-two = add-one 2 // or add 1, 2
assert add-one-and-two(3) == 6
</code></pre>
    
    <p>Simply by putting the caret (<code class="language-gorillascript">^</code>) after the function parameters, functions are automatically curried. Curried functions work extremely well in functional-style programming and are extremely handy when coupled with the compose operators (<code class="language-gorillascript">&lt;&lt;</code> and <code class="language-gorillascript">&gt;&gt;</code>)</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let sort-by(key, array)^
  array.sort #(a, b) -&gt; a[key] &lt;=&gt; b[key]

let sort-by-id = sort-by \id
let sort-by-name = sort-by \name

let items =
  * id: 0
    name: "Dog"
  * id: 1
    name: "Car"
  * id: 2
    name: "Robot"
  * id: 3
    name: "Guitar"

let items-by-name = sort-by-name items
let items-by-id = sort-by-id items
</code></pre>
    
    <p>It is not recommended to use currying with default arguments (e.g. <code class="language-gorillascript">#(x = 0)^</code>) or spread arguments (e.g. <code class="language-gorillascript">#(...args)</code>), since the curry helper checks a function's <code class="language-gorillascript">.length</code> to determine how many arguments before calling the actual function, and it may be non-obvious.</p>
  </section>
  
  <section id="generic">
    <h2>Generics</h2>
    
    <p>GorillaScript supports reified generic classes and functions, which are similar to .NET's generics or C++'s templates.</p>
    
    <p>If a function is called with generic arguments, it is converted as so:</p>
    
    <pre class="gs-code"><code class="language-gorillascript">func&lt;String&gt;("hello")
// turns into
func.generic(String)("hello")
</code></pre>

    <p>How the function handles the <code class="language-gorillascript">.generic</code> call can vary, but GorillaScript's classes handle it elegantly:</p>
    
    <pre class="gs-code"><code class="language-gorillascript">class MyClass&lt;T&gt;
  def constructor(@value as T) ->
  
  def get-value() as T
    @value

let wrapped-string = MyClass&lt;String&gt;("hello")
let wrapped-number = MyClass&lt;Number&gt;(1234)
let wrapped-any = MyClass({})
</code></pre>

    <p>In the previous case, <code class="language-gorillascript">MyClass&lt;String&gt;</code>, <code class="language-gorillascript">MyClass&lt;Number&gt;</code>, and <code class="language-gorillascript">MyClass</code> (same as <code class="language-gorillascript">MyClass&lt;null&gt;</code>) all refer to three independent classes which have different semantics.</p>
    
    <p>You may be wondering about <code class="language-gorillascript">MyClass&lt;null&gt;</code>, but it simply refers to absolutely any type being accepted, whether it's a <code class="language-gorillascript">String</code>, <code class="language-gorillascript">Object</code>, <code class="language-gorillascript">void</code>, or some custom object.</p>
    
    <p>Type-checking works as expected and <code class="language-gorillascript">T</code> (or whatever type you call it) is available at runtime to refer to the bound generic type.</p>
    
    <p>Here is an example of a simple function (rather than a class) with generic arguments:</p>
    
    <pre class="gs-code"><code class="language-gorillascript">let func&lt;T&gt;(value as T) -> value

assert func&lt;String&gt;("hello") == "hello"
assert func&lt;Number&gt;(1234) == 1234
assert func(true) == true // no type specified, so any type is allowed
assert func(null) == null
</code></pre>
    
    <p>It is recommended that you name your generic argument <code class="language-gorillascript">T</code> or have it start with the letter <code class="language-gorillascript">T</code>, as in <code class="language-gorillascript">TKey</code> or <code class="language-gorillascript">TResult</code>.</p>
  </section>
  
  <section id="gnome">
    <h2>GNOME bindings</h2>
    
    <p>GNOME now has JavaScript bindings with <a href="https://live.gnome.org/Gjs">Gjs</a> and GorillaScript supports this to the best of its ability.</p>
    
    <p>As long as you have <tt>gjs</tt> installed locally, there are three ways to run Gjs with GorillaScript:</p>
    
    <ul>
      <li><p>REPL: If you run <tt>gorilla --gjs</tt> or <tt>gjs-gorilla</tt>, a REPL opens that pipes its JavaScript code to <tt>gjs</tt></p></li>
      <li><p>Running a <tt>.gs</tt> file: If you run <tt>gorilla --gjs myfile.gs</tt> or <tt>gjs-gorilla myfile.gs</tt>, it will compile the code of <tt>myfile.gs</tt> and pipe its results to <tt>gjs</tt> all at once.</p></li>
      <li><p>Compile and run with <tt>gjs</tt>. You can compile any <tt>.gs</tt> file as per usual with <tt>gorilla -c</tt> and run the result <tt>.js</tt> file with <tt>gjs</tt>. You'll want to do this before distributing any code anyway.</p></li>
    </ul>
    
    <p>Aside from being written in GorillaScript rather than JavaScript, it will then function as any other Gjs script</p>
    
    <p>Here is the standard Hello World Gjs code converted to GorillaScript:</p>
    <pre class="gs-code"><code class="language-gorillascript">#!/usr/bin/env gjs-gorilla

let {Gtk, GLib} = imports.gi

// Initialize the gtk
Gtk.init null, 0

let mwindow = new Gtk.Window type: Gtk.WindowType.TOPLEVEL
let label = new Gtk.Label label: "Hello World"

// Set the window title
mwindow.title := "Hello World!"
mwindow.connect "destroy", #-> Gtk.main_quit()

// Add the label
mwindow.add label

// Show the widgets
label.show()
mwindow.show()

Gtk.main()
</code></pre>

  </section>
  
  <section id="gork">
    <h2>Gork and Gorkfiles</h2>
    
    <p>GorillaScript includes a simple build system called gork similar to <a href="http://www.gnu.org/software/make/">Make</a>. Commands and options are defined in GorillaScript syntax and are invoked through <tt>gork [--option] [command]</tt>. To receive a list of all commands, simply run <tt>gork</tt>.</p>
    
    <pre class="gs-code no-convert"><code class="language-gorillascript">require! fs

option "file", "f", "Build a specific file", "file"
command "build", "Rebuild file", #(options, cb)
  if not options.file
    return cb Error "A file is required"
  async! cb, filename-path &lt;- fs.realpath options.file
  require! './builder'
  async! cb, result &lt;- builder.build(filename-path)
  output = options.output or "lib"
  fs.write-file "$output/$(options.file.replace r'\.gs$', '.js')", result, cb

command "compress", "Compress file", #(options, cb) ->
  // this space intentionally left blank

command "build:full", "Rebuild all files", #(options, cb)
  async! cb &lt;- invoke "build"
  async! cb &lt;- invoke "compress"
  cb()
</code></pre>

    <p>As you can see, asynchrony is assumed. This is a powerful way to define simple command-line commands to run.</p>
  </section>
  
  <section id="browser">
    <h2>Browser support</h2>
    
    <p>Although not recommended for production code, there is a browser-specific version of the GorillaScript compiler as <tt>extras/gorillascript.js</tt>. Once this is included on your page, it will run any <code class="language-gorillascript">&lt;script type="text/gorillascript"&gt;</code> tags, with or without <code class="language-gorillascript">src="filename.gs"</code>. It compiles and runs each tag in-order.</p>
    
    <p>Caveat: this will not run synchronously like normal <code class="language-gorillascript">&lt;script&gt;</code> tags, so it is recommended to wait for an <code class="language-gorillascript">onload</code> event or something similar.</p>
    
    <p>Once <tt>extras/gorillascript.js</tt> is included, the global <code class="language-gorillascript">GorillaScript</code> object will be available, allowing you to use <code class="language-gorillascript">GorillaScript.compile("code", { options: "here" })</code> and several other commands.</p>
    
    <p>In fact, this is exactly how this page is designed. Most of the JavaScript (including in the code examples) is compiled on-the-fly, and the <a href="#try">Try it out</a> environment is handled in this very way.</p>
    
    <p>If <code class="language-gorillascript">define</code> and <code class="language-gorillascript">define.amd</code> are properly defined, they will be used instead of setting <code class="language-gorillascript">window.Gorilla</code>, as a proper <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">module definition</a></p>
    
    <p>Note: any compiled GorillaScript file should work in all browsers, including older browsers. Certain features like <a href="#properties">getters and setters</a> may not work in engines that do not support them, but this will cause a runtime exception on defining such properties rather than a compile-time error.</p>
  </section>
  
  <section id="irc">
    <h2>Chat with others (IRC)</h2>
    
    <p><a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat"><abbr title="Internet Relay Chat">IRC</abbr></a> is a way to chat with other GorillaScript developers, likely including the author (depending on) and other contributors. Feel free to join us at <tt>#gorillascript</tt> on <tt>irc.freenode.net</tt>.</p>
    
    <p><button id="irc-button" data-url="http://webchat.freenode.net/?channels=gorillascript">Click to open <tt>#gorillascript</tt></button></p>
  </section>
  
	</div>
	<footer>
		<p>GorillaScript is licensed under <a href="http://opensource.org/licenses/MIT">The MIT License</a></p>
	</footer>
  
  
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
  <script src="lib/code.min.js" data-manual="true"></script>
</body>
</html>

